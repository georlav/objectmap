package pentest

import (
	"bytes"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/georlav/objectmap/httpclient"
	"github.com/georlav/objectmap/insertionpoint"
	"github.com/georlav/objectmap/payload"

	"github.com/pkg/errors"
)

// PenTest object
type PenTest struct {
	Request      *http.Request
	ExpectInResp []byte
	Info         Info
	Retries      int
}

// Info objects keeps info about PenTest
type Info struct {
	URL            string
	Method         string
	InsertionPoint insertionpoint.InsertionPoint
	VulnName       string
}

func newPenTest(r *http.Request, expect []byte, i Info) PenTest {
	return PenTest{
		Request:      r,
		ExpectInResp: expect,
		Info:         i,
		Retries:      1,
	}
}

// PenTests slice to keep PenTest objects
type PenTests []PenTest

// NewPenTests creates PenTests
func NewPenTests(
	r *http.Response,
	ipts insertionpoint.InsertionPoints,
	payloads payload.Payloads,
	c httpclient.HTTPClient,
	concurrentRequests int,
) (chan PenTest, <-chan error) {
	ptCH := make(chan PenTest, concurrentRequests)
	errCH := make(chan error)

	go func() {
		for p := range payloads {
			for i := range ipts {

				switch ipts[i].Point {

				case insertionpoint.Param:
					pts, err := newParamTest(r.Request, ipts[i], payloads[p], c)
					if err != nil {
						errCH <- errors.Errorf("Failed to prepare %s test", insertionpoint.Param)
					}
					for i := range pts {
						ptCH <- pts[i]
					}

				case insertionpoint.Header:
					pts, err := newHeaderTest(r.Request, ipts[i], payloads[p], c)
					if err != nil {
						errCH <- errors.Errorf("Failed to prepare %s test", insertionpoint.Param)
					}
					for i := range pts {
						ptCH <- pts[i]
					}

				case insertionpoint.Cookie:
					pts, err := newCookieTest(r, ipts[i], payloads[p], c)
					if err != nil {
						errCH <- errors.Errorf("Failed to prepare %s test", insertionpoint.Param)
					}
					for i := range pts {
						ptCH <- pts[i]
					}

				}
			}
		}
		close(ptCH)
		close(errCH)
	}()

	return ptCH, errCH
}

func newParamTest(
	r *http.Request,
	ipt insertionpoint.InsertionPoint,
	payload payload.Payload,
	c httpclient.HTTPClient,
) (pts PenTests, err error) {
	b, err := httpclient.ReadBody(&r.Body)
	if err != nil {
		return pts, errors.Wrap(err, "failed to read request body")
	}

	err = r.ParseForm()
	if err != nil || len(r.Form) == 0 {
		return pts, errors.Wrap(err, "no params")
	}
	r.Body = ioutil.NopCloser(bytes.NewReader(b))

	for _, p := range payload.Input() {
		form := make(url.Values, len(r.Form))
		for k := range r.Form {
			form.Set(k, r.FormValue(k))
			if ipt.Name == k {
				form.Set(ipt.Name, string(p))
			}
		}

		req, err := c.NewRequest(r.Method, r.URL, strings.NewReader(form.Encode()))
		if err != nil {
			return pts, err
		}

		if req.Method == http.MethodGet {
			// nolint[:errcheck, gosec]
			uq, _ := url.QueryUnescape(form.Encode())
			req.URL.RawQuery = uq
		}

		for k := range r.Header {
			req.Header.Set(k, r.Header.Get(k))
		}

		for _, c := range r.Cookies() {
			req.AddCookie(c)
		}

		pts = append(pts, newPenTest(req, payload.Output(), Info{
			URL:            req.URL.String(),
			Method:         req.Method,
			InsertionPoint: ipt,
			VulnName:       payload.Description(),
		}))
	}

	return pts, nil
}

func newHeaderTest(
	r *http.Request,
	ipt insertionpoint.InsertionPoint,
	payload payload.Payload,
	c httpclient.HTTPClient,
) (pts PenTests, err error) {
	b, err := httpclient.ReadBody(&r.Body)
	if err != nil {
		return pts, errors.Wrap(err, "failed to read request body")
	}

	for _, p := range payload.Input() {
		// nolint:govet
		req, err := c.NewRequest(r.Method, r.URL, bytes.NewReader(b))
		if err != nil {
			return pts, err
		}

		for k := range r.Header {
			req.Header.Add(k, r.Header.Get(k))
			if ipt.Name == k {
				req.Header.Set(k, string(p))
			}
		}

		for _, c := range r.Cookies() {
			req.AddCookie(c)
		}

		pts = append(pts, newPenTest(req, payload.Output(), Info{
			URL:            req.URL.String(),
			Method:         req.Method,
			InsertionPoint: ipt,
			VulnName:       payload.Description(),
		}))
	}

	return pts, err
}

func newCookieTest(
	r *http.Response,
	ipt insertionpoint.InsertionPoint,
	payload payload.Payload,
	c httpclient.HTTPClient,
) (pts PenTests, err error) {
	b, err := httpclient.ReadBody(&r.Body)
	if err != nil {
		return pts, errors.Wrap(err, "failed to read request body")
	}

	for _, p := range payload.Input() {
		// nolint:govet
		req, err := c.NewRequest(r.Request.Method, r.Request.URL, bytes.NewReader(b))
		if err != nil {
			return pts, err
		}

		for k := range r.Request.Header {
			req.Header.Set(k, r.Request.Header.Get(k))
		}

		cookies := append(r.Request.Cookies(), r.Cookies()...)
		for _, c := range cookies {
			if c.Name == ipt.Name {
				c.Value = url.QueryEscape(string(p))
			}
			if ec, err := req.Cookie(c.Name); err == nil {
				ec.Value = c.Value
				continue
			}

			req.AddCookie(c)
		}

		pts = append(pts, newPenTest(req, payload.Output(), Info{
			URL:            req.URL.String(),
			Method:         req.Method,
			InsertionPoint: ipt,
			VulnName:       payload.Description(),
		}))
	}

	return pts, err
}
